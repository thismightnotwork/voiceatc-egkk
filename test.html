<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ATC STT → AI → TTS (Puter.js)</title>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 1.5rem; max-width: 900px; margin: auto; }
    h1 { font-size: 1.5rem; }
    #ptt {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #666;
      background: #eee;
    }
    #ptt.recording {
      background: #d9534f;
      color: white;
      border-color: #b52b27;
    }
    #status { margin-top: 0.5rem; color: #555; }
    #labels { margin-top: 1rem; display: flex; gap: 1rem; font-weight: 600; }
    #labels span { flex: 1; }
    #panels { display: flex; gap: 1rem; }
    #panels > div {
      flex: 1;
      white-space: pre-wrap;
      margin-top: 0.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 3rem;
    }
  </style>
</head>
<body>
  <h1>ATC Push‑to‑Talk – AI Pilot Reply</h1>
  <p>You speak as ATC (e.g. “Golf Oscar Lima Foxtrot, runway two seven cleared for takeoff…”). The AI understands it and replies as the pilot, then speaks the reply.</p>

  <button id="ptt">Hold to Talk (ATC)</button>
  <div id="status"></div>

  <div id="labels">
    <span>ATC (you)</span>
    <span>Pilot (AI)</span>
  </div>
  <div id="panels">
    <div id="you"></div>
    <div id="pilot"></div>
  </div>

  <script>
    const pttBtn = document.getElementById('ptt');
    const statusDiv = document.getElementById('status');
    const youDiv = document.getElementById('you');
    const pilotDiv = document.getElementById('pilot');

    let mediaRecorder;
    let chunks = [];

    async function initMedia() {
      if (mediaRecorder) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
        mediaRecorder.onstop = onStopRecording;
      } catch (err) {
        statusDiv.textContent = 'Mic error: ' + err.message;
      }
    }

    async function askPilotAI(atcText) {
      const systemPrompt =
        "You are the pilot in a UK CAA CAP 413 style RTF exchange.\n" +
        "You receive ATC transmissions as text and must reply with ONE short, realistic pilot readback.\n" +
        "Rules:\n" +
        "- Use standard ICAO/CAA radiotelephony phraseology, UK style.\n" +
        "- If the call sign is an airline flight (e.g. BAW123), use the correct telephony designator " +
        "instead of spelling letters: BAW = 'Speedbird', AFR = 'Airfrans', KLM = 'KLM', etc.\n" +
        "- If ATC or the pilot already use a telephony designator like 'Speedbird', keep using that; " +
        "do NOT convert it to the NATO alphabet.\n" +
        "- For UK G- registrations, you may use the NATO alphabet (e.g. G-ABCD → 'Golf Alpha Bravo Charlie Delta').\n" +
        "- Put the clearance or readback FIRST and the call sign LAST. Example: " +
        "'cleared for takeoff runway two seven, Speedbird one two three.'\n" +
        "- Be concise: read back only what is required.\n" +
        "- Output ONLY the pilot’s spoken transmission, no explanations.";

      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: "ATC transmission: \"" + atcText + "\"" }
      ];

      const resp = await puter.ai.chat(messages, {
        model: "gpt-5-nano",
        stream: false
      });

      if (typeof resp === "string") return resp;
      if (resp?.message?.content) return resp.message.content;
      if (resp?.choices?.[0]?.message?.content) return resp.choices[0].message.content;
      return "say again, please.";
    }

    async function speak(text) {
      // Free TTS through Puter; provider can be default or openai/polly per docs
      const audio = await puter.ai.txt2speech(text, {
        language: "en-GB"
      });
      await audio.play();
    }

    async function onStopRecording() {
      statusDiv.textContent = "Transcribing...";
      const blob = new Blob(chunks, { type: "audio/webm" });
      chunks = [];

      try {
        const result = await puter.ai.speech2txt(blob);
        const atcText = result.text || result || "";
        youDiv.textContent = atcText || "(No speech recognised)";

        if (!atcText) {
          const fallback = "no transmission received, say again.";
          pilotDiv.textContent = fallback;
          await speak(fallback);
          statusDiv.textContent = "Ready.";
          return;
        }

        statusDiv.textContent = "Asking AI to generate pilot reply...";
        const pilotText = await askPilotAI(atcText);
        pilotDiv.textContent = pilotText;

        statusDiv.textContent = "Speaking pilot reply...";
        await speak(pilotText);
        statusDiv.textContent = "Ready.";
      } catch (err) {
        console.error(err);
        statusDiv.textContent = "Error: " + err.message;
      }
    }

    // PTT handlers
    pttBtn.addEventListener("mousedown", async () => {
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("mouseup", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    pttBtn.addEventListener("mouseleave", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    // Touch support
    pttBtn.addEventListener("touchstart", async (e) => {
      e.preventDefault();
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });
  </script>
</body>
</html>

