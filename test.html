<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ATC STT → AI → TTS (Puter.js)</title>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 1.5rem; max-width: 900px; margin: auto; }
    h1 { font-size: 1.5rem; }
    #ptt {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #666;
      background: #eee;
    }
    #ptt.recording {
      background: #d9534f;
      color: white;
      border-color: #b52b27;
    }
    #status { margin-top: 0.5rem; color: #555; }
    #labels { margin-top: 1rem; display: flex; gap: 1rem; font-weight: 600; }
    #labels span { flex: 1; }
    #panels { display: flex; gap: 1rem; }
    #panels > div {
      flex: 1;
      white-space: pre-wrap;
      margin-top: 0.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 3rem;
    }
  </style>
</head>
<body>
  <h1>ATC Push‑to‑Talk – AI Pilot Reply</h1>
  <p>You speak as ATC (e.g. “Golf Oscar Lima Foxtrot, runway two seven cleared for takeoff…”). The AI understands it and replies as the pilot, then speaks the reply.</p>

  <button id="ptt">Hold to Talk (ATC)</button>
  <div id="status"></div>

  <div id="labels">
    <span>ATC (you)</span>
    <span>Pilot (AI)</span>
  </div>
  <div id="panels">
    <div id="you"></div>
    <div id="pilot"></div>
  </div>

  <script>
    const pttBtn = document.getElementById('ptt');
    const statusDiv = document.getElementById('status');
    const youDiv = document.getElementById('you');
    const pilotDiv = document.getElementById('pilot');

    let mediaRecorder;
    let chunks = [];

    async function initMedia() {
      if (mediaRecorder) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
        mediaRecorder.onstop = onStopRecording;
      } catch (err) {
        statusDiv.textContent = 'Mic error: ' + err.message;
      }
    }

    async function askPilotAI(atcText) {
  const text = atcText.toLowerCase();

  // --- 1. Extract callsign (very simple heuristic) ---
  // Try patterns like "g-abcd", "speedbird 123", "easy 456", etc.
  let callsign = "";
  const gReg = text.match(/\bg-?[a-z]{3,4}\b/i);          // G-ABCD, GABCD
  const airlineReg = text.match(/\b(speedbird|ryanair|easy|easyjet|british airways|wizzy|jet2)\s?\d{1,4}\b/i);

  if (airlineReg) {
    callsign = airlineReg[0];
  } else if (gReg) {
    callsign = gReg[0].replace(/\s+/g, "").toUpperCase();
  } else {
    // Fallback if we really don't know
    callsign = "Golf Oscar Lima Foxtrot";
  }

  // --- 2. Extract common slots ---
  const runwayMatch = text.match(/\brunway\s+(\d{2}[LRC]?)\b/);
  const runway = runwayMatch ? runwayMatch[1] : "";

  const qnhMatch = text.match(/\bqnh\s+(\d{3,4})\b/);
  const qnh = qnhMatch ? qnhMatch[1] : "";

  const levelMatch =
    text.match(/\bflight level\s+(\d{2,3})\b/) ||
    text.match(/\blevel\s+(\d{2,3})\b/) ||
    text.match(/\baltitude\s+(\d{3,5})\b/);
  const level = levelMatch ? levelMatch[1] : "";

  const headingMatch = text.match(/\bheading\s+(\d{2,3})\b/);
  const heading = headingMatch ? heading[1] : "";

  const squawkMatch = text.match(/\bsquawk\s+(\d{4})\b/);
  const squawk = squawkMatch ? squawkMatch[1] : "";

  // --- 3. Detect intent & build template reply ---
  let reply = "";

  if (text.includes("cleared for takeoff") || text.includes("cleared for departure")) {
    reply = runway
      ? `cleared for takeoff runway ${runway}, ${callsign}.`
      : `cleared for takeoff, ${callsign}.`;
  } else if (text.includes("line up") || text.includes("line-up")) {
    reply = runway
      ? `lining up runway ${runway}, ${callsign}.`
      : `lining up, ${callsign}.`;
  } else if (text.includes("taxi")) {
    // Very simple taxi readback
    reply = qnh
      ? `taxi as cleared, qnh ${qnh}, ${callsign}.`
      : `taxi as cleared, ${callsign}.`;
  } else if (text.includes("climb") || text.includes("descend") || text.includes("descend to") || text.includes("descend altitude")) {
    if (text.includes("climb")) {
      reply = level
        ? `climbing to ${level}, ${callsign}.`
        : `climbing as cleared, ${callsign}.`;
    } else {
      reply = level
        ? `descending to ${level}, ${callsign}.`
        : `descending as cleared, ${callsign}.`;
    }
  } else if (text.includes("heading")) {
    reply = heading
      ? `turning heading ${heading}, ${callsign}.`
      : `turning as instructed, ${callsign}.`;
  } else if (text.includes("qnh")) {
    reply = qnh
      ? `qnh ${qnh} set, ${callsign}.`
      : `qnh set, ${callsign}.`;
  } else if (text.includes("squawk")) {
    reply = squawk
      ? `squawking ${squawk}, ${callsign}.`
      : `squawking as assigned, ${callsign}.`;
  } else if (text.includes("contact") || text.includes("frequency")) {
    reply = `changing frequency, ${callsign}.`;
  } else if (text.includes("report") && text.includes("ready") || text.includes("ready for departure")) {
    reply = `wilco, ${callsign}.`;
  } else {
    // Fallback generic readback
    reply = `roger, ${callsign}.`;
  }

  return reply;
}

    async function speak(text) {
      // Free TTS through Puter; provider can be default or openai/polly per docs
      const audio = await puter.ai.txt2speech(text, {
        language: "en-GB"
      });
      await audio.play();
    }

    async function onStopRecording() {
      statusDiv.textContent = "Transcribing...";
      const blob = new Blob(chunks, { type: "audio/webm" });
      chunks = [];

      try {
        const result = await puter.ai.speech2txt(blob);
        const atcText = result.text || result || "";
        youDiv.textContent = atcText || "(No speech recognised)";

        if (!atcText) {
          const fallback = "no transmission received, say again.";
          pilotDiv.textContent = fallback;
          await speak(fallback);
          statusDiv.textContent = "Ready.";
          return;
        }

        statusDiv.textContent = "Asking AI to generate pilot reply...";
        const pilotText = await askPilotAI(atcText);
        pilotDiv.textContent = pilotText;

        statusDiv.textContent = "Speaking pilot reply...";
        await speak(pilotText);
        statusDiv.textContent = "Ready.";
      } catch (err) {
        console.error(err);
        statusDiv.textContent = "Error: " + err.message;
      }
    }

    // PTT handlers
    pttBtn.addEventListener("mousedown", async () => {
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("mouseup", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    pttBtn.addEventListener("mouseleave", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    // Touch support
    pttBtn.addEventListener("touchstart", async (e) => {
      e.preventDefault();
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });
  </script>
</body>
</html>


