<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ATC STT → AI → TTS (Puter.js)</title>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 1.5rem; max-width: 900px; margin: auto; }
    h1 { font-size: 1.5rem; }
    #ptt {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #666;
      background: #eee;
    }
    #ptt.recording {
      background: #d9534f;
      color: white;
      border-color: #b52b27;
    }
    #status { margin-top: 0.5rem; color: #555; }
    #labels { margin-top: 1rem; display: flex; gap: 1rem; font-weight: 600; }
    #labels span { flex: 1; }
    #panels { display: flex; gap: 1rem; }
    #panels > div {
      flex: 1;
      white-space: pre-wrap;
      margin-top: 0.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 3rem;
    }
  </style>
</head>
<body>
  <h1>ATC Push‑to‑Talk – AI Pilot Reply</h1>
  <p>You speak as ATC. The AI replies as the pilot using CAP‑style RTF, with a fast template path and a slow LLM fallback.</p>

  <button id="ptt">Hold to Talk (ATC)</button>
  <div id="status"></div>

  <div id="labels">
    <span>ATC (you)</span>
    <span>Pilot (AI)</span>
  </div>
  <div id="panels">
    <div id="you"></div>
    <div id="pilot"></div>
  </div>

  <script>
    const pttBtn = document.getElementById('ptt');
    const statusDiv = document.getElementById('status');
    const youDiv = document.getElementById('you');
    const pilotDiv = document.getElementById('pilot');

    let mediaRecorder;
    let chunks = [];

    async function initMedia() {
      if (mediaRecorder) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
        mediaRecorder.onstop = onStopRecording;
      } catch (err) {
        statusDiv.textContent = 'Mic error: ' + err.message;
      }
    }

    // ---------- FAST TEMPLATE ENGINE ----------

    function buildPilotReplyFast(atcText) {
      if (!atcText) return null;
      const text = atcText.toLowerCase();

      // --- Callsign extraction (simple heuristics) ---
      let callsign = "";
      const gReg = text.match(/\bg-?[a-z]{3,4}\b/i); // G-ABCD, GABCD
      const airlineReg = text.match(/\b(speedbird|ryanair|easyjet|easy|jet2|wizzair|tui|loganair|aer lingus)\s?\d{1,4}\b/i);

      if (airlineReg) {
        callsign = airlineReg[0];
      } else if (gReg) {
        callsign = gReg[0].replace(/\s+/g, "").toUpperCase();
      } else {
        callsign = "Golf Oscar Lima Foxtrot";
      }

      // Normalise some spacing
      callsign = callsign.replace(/\s{2,}/g, " ");

      // --- Slot extraction ---
      const runwayMatch = text.match(/\brunway\s+(\d{2}[lrc]?)\b/);
      const runway = runwayMatch ? runwayMatch[1] : "";

      const qnhMatch = text.match(/\bqnh\s+(\d{3,4})\b/);
      const qnh = qnhMatch ? qnhMatch[1] : "";

      const levelMatch =
        text.match(/\bflight level\s+(\d{2,3})\b/) ||
        text.match(/\bfl\s*(\d{2,3})\b/) ||
        text.match(/\blevel\s+(\d{2,3})\b/) ||
        text.match(/\baltitude\s+(\d{3,5})\b/) ||
        text.match(/\bclimb(?:\s+to)?\s+(\d{3,5})\b/) ||
        text.match(/\bdescend(?:\s+to)?\s+(\d{3,5})\b/);
      const level = levelMatch ? levelMatch[1] : "";

      const headingMatch = text.match(/\bheading\s+(\d{2,3})\b/);
      const heading = headingMatch ? heading[1] : "";

      const squawkMatch = text.match(/\bsquawk\s+(\d{4})\b/);
      const squawk = squawkMatch ? squawkMatch[1] : "";

      const speedMatch = text.match(/\b(?:speed|maintain speed|reduce speed to|increase speed to)\s+(\d{2,3})\b/);
      const speed = speedMatch ? speedMatch[1] : "";

      const freqMatch = text.match(/\b(\d{3}\.\d{1,3})\b/);
      const freq = freqMatch ? freqMatch[1] : "";

      const directMatch = text.match(/\bdirect\s+([a-z0-9]+)\b/);
      const directFix = directMatch ? directMatch[1].toUpperCase() : "";

      const holdFixMatch = text.match(/\bhold(?:ing)?\s+at\s+([a-z0-9]+)\b/);
      const holdFix = holdFixMatch ? holdFixMatch[1].toUpperCase() : "";

      const localiserMatch = text.match(/\blocaliser\b|\bloc(?:alizer)?\b/);
      const ilsMatch = text.match(/\bils\b/);

      let reply = "";

      // ---------- DEPARTURE / LINE-UP / TAKE-OFF ----------
      if (text.includes("cleared for takeoff") || text.includes("cleared for departure")) {
        reply = runway
          ? `cleared for takeoff runway ${runway}, ${callsign}.`
          : `cleared for takeoff, ${callsign}.`;

      } else if (text.includes("line up and wait") || text.includes("line up") || text.includes("line-up")) {
        reply = runway
          ? `lining up runway ${runway}, ${callsign}.`
          : `lining up, ${callsign}.`;

      } else if (text.includes("backtrack")) {
        reply = runway
          ? `backtracking runway ${runway}, ${callsign}.`
          : `backtracking, ${callsign}.`;

      // ---------- ARRIVAL / APPROACH / LANDING ----------
      } else if (text.includes("cleared to land")) {
        reply = runway
          ? `cleared to land runway ${runway}, ${callsign}.`
          : `cleared to land, ${callsign}.`;

      } else if (text.includes("continue approach")) {
        reply = `continuing approach, ${callsign}.`;

      } else if (text.includes("join base") || text.includes("join final") || text.includes("join downwind")) {
        if (text.includes("base")) {
          reply = `joining base leg, ${callsign}.`;
        } else if (text.includes("downwind")) {
          reply = `joining downwind, ${callsign}.`;
        } else {
          reply = `joining final, ${callsign}.`;
        }

      } else if (text.includes("go around") || text.includes("go-around")) {
        if (heading && level) {
          reply = `going around, heading ${heading}, ${level}, ${callsign}.`;
        } else if (heading) {
          reply = `going around, heading ${heading}, ${callsign}.`;
        } else {
          reply = `going around, ${callsign}.`;
        }

      } else if (ilsMatch || localiserMatch) {
        reply = runway
          ? `established on the localiser runway ${runway}, ${callsign}.`
          : `established on the localiser, ${callsign}.`;

      // ---------- TAXI / GROUND ----------
      } else if (text.includes("taxi")) {
        if (text.includes("hold short") || text.includes("hold at") || text.includes("hold before")) {
          reply = runway
            ? `taxiing as cleared, holding short runway ${runway}, ${callsign}.`
            : `taxiing as cleared, holding short, ${callsign}.`;
        } else {
          reply = qnh
            ? `taxi as cleared, qnh ${qnh} set, ${callsign}.`
            : `taxi as cleared, ${callsign}.`;
        }

      } else if (text.includes("vacate") || text.includes("exit runway")) {
        reply = runway
          ? `vacating runway ${runway}, ${callsign}.`
          : `vacating runway, ${callsign}.`;

      } else if (text.includes("cross runway")) {
        reply = runway
          ? `crossing runway ${runway}, ${callsign}.`
          : `crossing runway, ${callsign}.`;

      // ---------- CLIMB / DESCENT / LEVEL ----------
      } else if (text.includes("climb") || text.includes("descend")) {
        if (text.includes("climb")) {
          reply = level
            ? `climbing to ${level}, ${callsign}.`
            : `climbing as cleared, ${callsign}.`;
        } else {
          reply = level
            ? `descending to ${level}, ${callsign}.`
            : `descending as cleared, ${callsign}.`;
        }

      } else if (text.includes("maintain") && (text.includes("flight level") || text.includes("altitude"))) {
        reply = level
          ? `maintaining ${level}, ${callsign}.`
          : `maintaining as cleared, ${callsign}.`;

      } else if (text.includes("level off") || text.includes("stop climb") || text.includes("stop descent")) {
        reply = `stopping climb / descent as instructed, ${callsign}.`;

      // ---------- HEADING / VECTORS ----------
      } else if (text.includes("turn left") || text.includes("turn right") || text.includes("heading")) {
        reply = heading
          ? `turning heading ${heading}, ${callsign}.`
          : `turning as instructed, ${callsign}.`;

      } else if (text.includes("fly direct") || text.includes("proceed direct") || text.includes("direct")) {
        reply = directFix
          ? `proceeding direct ${directFix}, ${callsign}.`
          : `proceeding as instructed, ${callsign}.`;

      // ---------- SPEED CONTROL ----------
      } else if (text.includes("reduce speed") || text.includes("increase speed") || text.includes("maintain speed") || text.includes("not above") || text.includes("not less than")) {
        reply = speed
          ? `speed ${speed} knots, ${callsign}.`
          : `speed as instructed, ${callsign}.`;

      // ---------- HOLDING / HOLDS ----------
      } else if (text.includes("hold") && (text.includes("pattern") || text.includes("holding"))) {
        if (holdFix) {
          reply = `holding at ${holdFix} as instructed, ${callsign}.`;
        } else {
          reply = `holding as instructed, ${callsign}.`;
        }

      // ---------- QNH / ALTIMETER ----------
      } else if (text.includes("qnh")) {
        reply = qnh
          ? `qnh ${qnh} set, ${callsign}.`
          : `qnh set, ${callsign}.`;

      } else if (text.includes("qfe")) {
        const qfeMatch = text.match(/\bqfe\s+(\d{3,4})\b/);
        const qfe = qfeMatch ? qfeMatch[1] : "";
        reply = qfe
          ? `qfe ${qfe} set, ${callsign}.`
          : `qfe set, ${callsign}.`;

      // ---------- SQUAWK / TRANSPONDER ----------
      } else if (text.includes("squawk") || text.includes("transponder")) {
        if (text.includes("ident") || text.includes("identification")) {
          reply = `squawk ident, ${callsign}.`;
        } else {
          reply = squawk
            ? `squawking ${squawk}, ${callsign}.`
            : `squawking as assigned, ${callsign}.`;
        }

      } else if (text.includes("stop squawk") || text.includes("squawk standby")) {
        reply = `transponder standby, ${callsign}.`;

      // ---------- FREQUENCY CHANGE / HAND-OFF ----------
      } else if (text.includes("contact") || text.includes("monitor") || text.includes("change to")) {
        reply = freq
          ? `changing to ${freq}, ${callsign}.`
          : `changing frequency, ${callsign}.`;

      // ---------- POSITION / TRAFFIC / CIRCUIT ----------
      } else if (text.includes("report final") || text.includes("report downwind") || text.includes("report base") || text.includes("report overhead")) {
        if (text.includes("final")) {
          reply = `will report final, ${callsign}.`;
        } else if (text.includes("downwind")) {
          reply = `will report downwind, ${callsign}.`;
        } else if (text.includes("base")) {
          reply = `will report base, ${callsign}.`;
        } else if (text.includes("overhead")) {
          reply = `will report overhead, ${callsign}.`;
        } else {
          reply = `wilco, ${callsign}.`;
        }

      } else if (text.includes("report ready")) {
        reply = `will report ready, ${callsign}.`;

      } else if (text.includes("traffic")) {
        if (text.includes("in sight")) {
          reply = `traffic in sight, ${callsign}.`;
        } else if (text.includes("not in sight") || text.includes("no visual")) {
          reply = `negative contact, ${callsign}.`;
        } else {
          reply = `looking out, ${callsign}.`;
        }

      // ---------- MISC GENERAL ACKS ----------
      } else if (text.includes("hold position")) {
        reply = `holding position, ${callsign}.`;

      } else if (text.includes("hold short")) {
        reply = runway
          ? `holding short runway ${runway}, ${callsign}.`
          : `holding short, ${callsign}.`;

      } else if (text.includes("standby")) {
        reply = `standing by, ${callsign}.`;

      } else if (text.includes("readback correct") || text.includes("correct")) {
        reply = `roger, ${callsign}.`;

      } else if (text.includes("say again")) {
        reply = `say again, ${callsign}.`;

      } else if (text.includes("confirm")) {
        reply = `affirm, ${callsign}.`;
      }

      // If nothing matched, return null -> triggers slow LLM path
      if (!reply) return null;
      return reply;
    }

    // ---------- SLOW-PATH LLM FALLBACK ----------

    async function askPilotAI(atcText) {
      const fast = buildPilotReplyFast(atcText);
      if (fast) return fast;

      const systemPrompt =
        "You are the pilot in a UK CAA CAP 413 style RTF exchange.\n" +
        "You receive ATC transmissions as text and must reply with ONE short, realistic pilot readback.\n" +
        "Rules:\n" +
        "- Use standard ICAO/CAA radiotelephony phraseology, UK style.\n" +
        "- If the call sign is an airline flight (e.g. BAW123), use the correct telephony designator " +
        "instead of spelling letters: BAW = 'Speedbird', AFR = 'Airfrans', KLM = 'KLM', etc.\n" +
        "- If ATC or the pilot already use a telephony designator like 'Speedbird', keep using that; " +
        "do NOT convert it to the NATO alphabet.\n" +
        "- For UK G- registrations, you may use the NATO alphabet (e.g. G-ABCD → 'Golf Alpha Bravo Charlie Delta').\n" +
        "- Put the clearance or readback FIRST and the call sign LAST. Example: " +
        "'cleared for takeoff runway two seven, Speedbird one two three.'\n" +
        "- Be concise: read back only what is required.\n" +
        "- Output ONLY the pilot’s spoken transmission, no explanations.";

      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: "ATC transmission: \"" + atcText + "\"" }
      ];

      const resp = await puter.ai.chat(messages, {
        model: "gpt-5-nano",
        stream: false
      });

      if (typeof resp === "string") return resp;
      if (resp?.message?.content) return resp.message.content;
      if (resp?.choices?.[0]?.message?.content) return resp.choices[0].message.content;
      return "say again, please.";
    }

    // ---------- TTS WRAPPER ----------

    async function speak(text) {
      const audio = await puter.ai.txt2speech(text, {
        language: "en-GB"
      });
      await audio.play();
    }

    // ---------- RECORD / PROCESS LOOP ----------

    async function onStopRecording() {
      statusDiv.textContent = "Transcribing...";
      const blob = new Blob(chunks, { type: "audio/webm" });
      chunks = [];

      try {
        const result = await puter.ai.speech2txt(blob);
        const atcText = result.text || result || "";
        youDiv.textContent = atcText || "(No speech recognised)";

        if (!atcText) {
          const fallback = "no transmission received, say again.";
          pilotDiv.textContent = fallback;
          await speak(fallback);
          statusDiv.textContent = "Ready.";
          return;
        }

        statusDiv.textContent = "Generating pilot reply...";
        const pilotText = await askPilotAI(atcText);
        pilotDiv.textContent = pilotText;

        statusDiv.textContent = "Speaking pilot reply...";
        await speak(pilotText);
        statusDiv.textContent = "Ready.";
      } catch (err) {
        console.error(err);
        statusDiv.textContent = "Error: " + err.message;
      }
    }

    // ---------- PTT HANDLERS ----------

    pttBtn.addEventListener("mousedown", async () => {
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("mouseup", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    pttBtn.addEventListener("mouseleave", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    // Touch support
    pttBtn.addEventListener("touchstart", async (e) => {
      e.preventDefault();
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });
  </script>
</body>
</html>
