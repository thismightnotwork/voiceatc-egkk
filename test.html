<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ATC STT → AI → TTS (Puter.js)</title>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 1.5rem; max-width: 1000px; margin: auto; }
    h1 { font-size: 1.5rem; }
    #ptt {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #666;
      background: #eee;
    }
    #ptt.recording {
      background: #d9534f;
      color: white;
      border-color: #b52b27;
    }
    #status { margin-top: 0.5rem; color: #555; }
    #labels { margin-top: 1rem; display: flex; gap: 1rem; font-weight: 600; }
    #labels span { flex: 1; }
    #panels { display: flex; gap: 1rem; }
    #panels > div {
      flex: 1;
      white-space: pre-wrap;
      margin-top: 0.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 3rem;
    }
    #examples {
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: #fafafa;
      font-size: 0.95rem;
    }
    #examples h2 {
      margin-top: 0;
      font-size: 1.1rem;
    }
    #examples code {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0.25rem 0;
      background: #f0f0f0;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>ATC Push‑to‑Talk – AI Pilot Reply</h1>
  <p>You speak as ATC. The AI replies as the pilot using UK CAP‑style RTF, with a fast local template path and a slow LLM fallback.</p>

  <button id="ptt">Hold to Talk (ATC)</button>
  <div id="status"></div>

  <div id="labels">
    <span>ATC (you)</span>
    <span>Pilot (AI)</span>
  </div>
  <div id="panels">
    <div id="you"></div>
    <div id="pilot"></div>
  </div>

  <div id="examples">
    <h2>Example ATC phrases you can say</h2>
    <p>These are examples of things you can speak; the AI will generate a matching pilot readback quickly.</p>
    <code>“Golf Oscar Lima Foxtrot, runway two six left cleared for takeoff, surface wind two seven zero degrees one zero knots.”</code>
    <small>Pilot reply: “cleared for takeoff runway two six left, Golf Oscar Lima Foxtrot.”</small>

    <code>“Speedbird one two three, line up and wait runway zero nine right.”</code>
    <small>Pilot reply: “lining up runway zero nine right, Speedbird one two three.”</small>

    <code>“Golf Tango Echo Sierra Tango, descend to altitude two thousand feet, QNH one zero one three.”</code>
    <small>Pilot reply: “descending to two thousand, QNH one zero one three set, Golf Tango Echo Sierra Tango.”</small>

    <code>“Speedbird one two three, turn left heading one eight zero, reduce speed to one six zero knots.”</code>
    <small>Pilot reply: “turning heading one eight zero, speed one six zero knots, Speedbird one two three.”</small>

    <code>“Golf Oscar Lima Foxtrot, report downwind runway two six left.”</code>
    <small>Pilot reply: “will report downwind, Golf Oscar Lima Foxtrot.”</small>

    <code>“Golf Oscar Lima Foxtrot, squawk seven thousand.”</code>
    <small>Pilot reply: “squawking seven thousand, Golf Oscar Lima Foxtrot.”</small>

    <code>“EZY four five, cleared LAM three X-ray departure runway two seven right.”</code>
    <small>Pilot reply: “cleared LAM three X-ray departure runway two seven right, Easy four five.”</small>

    <code>“Speedbird one two three, contact London Control one two seven decimal eight two five.”</code>
    <small>Pilot reply: “changing to one two seven decimal eight two five, Speedbird one two three.”</small>
  </div>

  <script>
    const pttBtn = document.getElementById('ptt');
    const statusDiv = document.getElementById('status');
    const youDiv = document.getElementById('you');
    const pilotDiv = document.getElementById('pilot');

    let mediaRecorder;
    let chunks = [];

    async function initMedia() {
      if (mediaRecorder) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
        mediaRecorder.onstop = onStopRecording;
      } catch (err) {
        statusDiv.textContent = 'Mic error: ' + err.message;
      }
    }

    // ---------- PHONETIC / NUMBER HELPERS ----------

    // ICAO-style number pronunciation (simplified digit-by-digit).[web:118]
    function spellNumberDigits(numStr) {
      const map = {
        "0": "zero",
        "1": "one",
        "2": "two",
        "3": "three",
        "4": "four",
        "5": "five",
        "6": "six",
        "7": "seven",
        "8": "eight",
        "9": "nine"
      };
      return (numStr || "").split("").map(d => map[d] || d).join(" ");
    }

    // Convert "26L" -> "two six left", "09R" -> "zero nine right".[web:95][web:102]
    function speakRunway(designator) {
      if (!designator) return "";
      const numPart = designator.match(/\d{2}/);
      const letterPart = designator.match(/[lrc]/i);
      if (!numPart) return designator;

      const digitWords = spellNumberDigits(numPart[0]);
      let side = "";
      if (letterPart) {
        const l = letterPart[0].toLowerCase();
        if (l === "l") side = " left";
        else if (l === "r") side = " right";
        else if (l === "c") side = " centre";
      }
      return `${digitWords}${side}`;
    }

    // NATO phonetic for arbitrary registration/tail (GA + custom).[web:115][web:116]
    function speakTailPhonetic(raw) {
      if (!raw) return "";
      const map = {
        A: "Alpha", B: "Bravo", C: "Charlie", D: "Delta", E: "Echo",
        F: "Foxtrot", G: "Golf", H: "Hotel", I: "India", J: "Juliett",
        K: "Kilo", L: "Lima", M: "Mike", N: "November", O: "Oscar",
        P: "Papa", Q: "Quebec", R: "Romeo", S: "Sierra", T: "Tango",
        U: "Uniform", V: "Victor", W: "Whiskey", X: "Xray", Y: "Yankee", Z: "Zulu"
      };
      // Keep first nationality letter, drop optional dash; speak rest as phonetics / digits.[web:143][web:137]
      const cleaned = raw.toUpperCase().replace(/^[A-Z]-?/, match => match[0]);
      return cleaned.split("").map(ch => map[ch] || spellNumberDigits(ch)).join(" ");
    }

    // Airline telephony + number (generic) and GA tails.[web:135][web:139]
    function normaliseCallsign(raw) {
      if (!raw) return "Golf Oscar Lima Foxtrot";
      const t = raw.toUpperCase().trim();

      // If it looks like "BAW123" or "EZY 45A".
      const airlinePattern = /^([A-Z]{2,8})\s?(\d{1,4}[A-Z]?)$/;
      const m = t.match(airlinePattern);
      if (m) {
        const telephony = m[1];
        const numberPart = m[2];
        const spokenNumber = spellNumberDigits(numberPart.replace(/[A-Z]$/, match => " " + match));
        // Common ICAO operator codes → telephony words.[web:134][web:139]
        const telephonyMap = {
          BAW: "Speedbird",
          EZY: "Easy",
          RYR: "Ryanair",
          KLM: "KLM",
          AFR: "Airfrans",
          DLH: "Lufthansa",
          VLG: "Vueling",
          WZZ: "Wizz Air",
          TUI: "TUI"
        };
        const spokenTelephony = telephonyMap[telephony] || telephony;
        return `${spokenTelephony} ${spokenNumber}`;
      }

      // If controller already used telephony word, keep it.[web:135]
      if (t.startsWith("SPEEDBIRD")) return t.replace("SPEEDBIRD", "Speedbird");
      if (t.startsWith("RYANAIR")) return t.replace("RYANAIR", "Ryanair");
      if (t.startsWith("EASYJET") || t.startsWith("EASY ")) return t.replace(/EASY(JET)?/, "Easy");
      if (t.startsWith("JET2")) return t.replace("JET2", "Jet two");
      if (t.startsWith("TUI")) return t.replace("TUI", "TUI");
      if (t.startsWith("LOGANAIR")) return t.replace("LOGANAIR", "Loganair");

      // Otherwise treat as GA / tail number.
      return speakTailPhonetic(t);
    }

    // ---------- FAST TEMPLATE ENGINE (IFR + VFR) ----------

    function buildPilotReplyFast(atcText) {
      if (!atcText) return null;
      const text = atcText.toLowerCase();

      // Callsign extraction: airline or GA / custom tail.[web:137]
      let callsignRaw = "";
      const airlineReg = text.match(/\b([a-z]{2,8})\s?\d{1,4}[a-z]?\b/i);
      const tailReg = text.match(/\b[a-z]{1,2}-?[a-z0-9]{3,5}\b/i);

      if (airlineReg) {
        callsignRaw = airlineReg[0];
      } else if (tailReg) {
        callsignRaw = tailReg[0];
      } else {
        callsignRaw = "G-OLF";
      }
      const callsign = normaliseCallsign(callsignRaw);

      // Slot extraction.
      const runwayMatch = text.match(/\brunway\s+(\d{2}[lrc]?)\b/);
      const runway = runwayMatch ? runwayMatch[1] : "";
      const speakableRunway = speakRunway(runway);

      const qnhMatch = text.match(/\bqnh\s+(\d{3,4})\b/);
      const qnh = qnhMatch ? qnhMatch[1] : "";

      const levelMatch =
        text.match(/\bflight level\s+(\d{2,3})\b/) ||
        text.match(/\bfl\s*(\d{2,3})\b/) ||
        text.match(/\blevel\s+(\d{2,3})\b/) ||
        text.match(/\baltitude\s+(\d{3,5})\b/) ||
        text.match(/\bclimb(?:\s+to)?\s+(\d{3,5})\b/) ||
        text.match(/\bdescend(?:\s+to)?\s+(\d{3,5})\b/);
      const levelRaw = levelMatch ? levelMatch[1] : "";
      const levelSpoken = levelRaw ? spellNumberDigits(levelRaw) : "";

      const headingMatch = text.match(/\bheading\s+(\d{2,3})\b/);
      const headingRaw = headingMatch ? headingMatch[1] : "";
      const headingSpoken = headingRaw ? spellNumberDigits(headingRaw) : "";

      const squawkMatch = text.match(/\bsquawk\s+(\d{4})\b/);
      const squawkRaw = squawkMatch ? squawkMatch[1] : "";
      const squawkSpoken = squawkRaw ? squawkRaw.split("").map(d => spellNumberDigits(d)).join(" ") : "";

      const speedMatch = text.match(/\b(?:speed|maintain speed|reduce speed to|increase speed to)\s+(\d{2,3})\b/);
      const speedRaw = speedMatch ? speedMatch[1] : "";
      const speedSpoken = speedRaw ? spellNumberDigits(speedRaw) : "";

      const freqMatch = text.match(/\b(\d{3}\.\d{1,3})\b/);
      const freqRaw = freqMatch ? freqMatch[1] : "";
      const freqSpoken = freqRaw
        ? freqRaw.replace(".", " decimal ").split(/\s*decimal\s*/).map(part => spellNumberDigits(part)).join(" decimal ")
        : "";

      const directMatch = text.match(/\bdirect\s+([a-z0-9]+)\b/);
      const directFix = directMatch ? directMatch[1].toUpperCase() : "";

      const holdFixMatch = text.match(/\bhold(?:ing)?\s+at\s+([a-z0-9]+)\b/);
      const holdFix = holdFixMatch ? holdFixMatch[1].toUpperCase() : "";

      const ilsMatch = text.match(/\bils\b/);
      const localiserMatch = text.match(/\blocaliser\b|\bloc(?:alizer)?\b/);

      const sidMatch = text.match(/\b([a-z0-9]+)\s+sid\b/);
      const starMatch = text.match(/\b([a-z0-9]+)\s+star\b/);
      const sidName = sidMatch ? sidMatch[1].toUpperCase() : "";
      const starName = starMatch ? starMatch[1].toUpperCase() : "";

      const squawk7000 = text.includes("7000");
      const squawk2000 = text.includes("2000");

      let reply = "";

      // DEPARTURE / LINE-UP / TAKEOFF (IFR+VFR)
      if (text.includes("cleared for takeoff") || text.includes("cleared for departure")) {
        reply = runway
          ? `cleared for takeoff runway ${speakableRunway}, ${callsign}.`
          : `cleared for takeoff, ${callsign}.`;

      } else if (text.includes("line up and wait") || text.includes("line up") || text.includes("line-up")) {
        reply = runway
          ? `lining up runway ${speakableRunway}, ${callsign}.`
          : `lining up, ${callsign}.`;

      } else if (text.includes("backtrack")) {
        reply = runway
          ? `backtracking runway ${speakableRunway}, ${callsign}.`
          : `backtracking, ${callsign}.`;

      } else if (sidName && (text.includes("cleared") || text.includes("departure via"))) {
        reply = runway
          ? `cleared ${sidName} departure runway ${speakableRunway}, ${callsign}.`
          : `cleared ${sidName} departure, ${callsign}.`;

      } else if (text.includes("after departure")) {
        reply = `after departure as cleared, ${callsign}.`;

      // ARRIVAL / APPROACH / LANDING (IFR+VFR)
      } else if (text.includes("cleared to land")) {
        reply = runway
          ? `cleared to land runway ${speakableRunway}, ${callsign}.`
          : `cleared to land, ${callsign}.`;

      } else if (text.includes("land at your discretion")) {
        reply = runway
          ? `landing at my discretion runway ${speakableRunway}, ${callsign}.`
          : `landing at my discretion, ${callsign}.`;

      } else if (text.includes("continue approach")) {
        reply = `continuing approach, ${callsign}.`;

      } else if (starName && text.includes("cleared")) {
        reply = `cleared ${starName} arrival, ${callsign}.`;

      } else if (text.includes("join base") || text.includes("join final") || text.includes("join downwind") || text.includes("join overhead")) {
        if (text.includes("base")) {
          reply = `joining base leg, ${callsign}.`;
        } else if (text.includes("downwind")) {
          reply = `joining downwind, ${callsign}.`;
        } else if (text.includes("overhead")) {
          reply = `joining overhead, ${callsign}.`;
        } else {
          reply = `joining final, ${callsign}.`;
        }

      } else if (text.includes("go around") || text.includes("go-around")) {
        if (headingSpoken && levelSpoken) {
          reply = `going around, heading ${headingSpoken}, ${levelSpoken}, ${callsign}.`;
        } else if (headingSpoken) {
          reply = `going around, heading ${headingSpoken}, ${callsign}.`;
        } else {
          reply = `going around, ${callsign}.`;
        }

      } else if (ilsMatch || localiserMatch) {
        reply = runway
          ? `established on the localiser runway ${speakableRunway}, ${callsign}.`
          : `established on the localiser, ${callsign}.`;

      // TAXI / GROUND
      } else if (text.includes("taxi")) {
        if (text.includes("hold short") || text.includes("hold at") || text.includes("hold before")) {
          reply = runway
            ? `taxiing as cleared, holding short runway ${speakableRunway}, ${callsign}.`
            : `taxiing as cleared, holding short, ${callsign}.`;
        } else {
          reply = qnh
            ? `taxi as cleared, QNH ${spellNumberDigits(qnh)} set, ${callsign}.`
            : `taxi as cleared, ${callsign}.`;
        }

      } else if (text.includes("vacate") || text.includes("exit runway")) {
        reply = runway
          ? `vacating runway ${speakableRunway}, ${callsign}.`
          : `vacating runway, ${callsign}.`;

      } else if (text.includes("cross runway")) {
        reply = runway
          ? `crossing runway ${speakableRunway}, ${callsign}.`
          : `crossing runway, ${callsign}.`;

      // CLIMB / DESCENT / LEVEL
      } else if (text.includes("climb") || text.includes("descend")) {
        if (text.includes("climb")) {
          reply = levelSpoken
            ? `climbing to ${levelSpoken}, ${callsign}.`
            : `climbing as cleared, ${callsign}.`;
        } else {
          reply = levelSpoken
            ? `descending to ${levelSpoken}, ${callsign}.`
            : `descending as cleared, ${callsign}.`;
        }

      } else if (text.includes("maintain") && (text.includes("flight level") || text.includes("altitude"))) {
        reply = levelSpoken
          ? `maintaining ${levelSpoken}, ${callsign}.`
          : `maintaining as cleared, ${callsign}.`;

      } else if (text.includes("level off") || text.includes("stop climb") || text.includes("stop descent")) {
        reply = `stopping climb or descent as instructed, ${callsign}.`;

      // HEADING / VECTORS
      } else if (text.includes("turn left") || text.includes("turn right") || text.includes("heading")) {
        reply = headingSpoken
          ? `turning heading ${headingSpoken}, ${callsign}.`
          : `turning as instructed, ${callsign}.`;

      } else if (text.includes("fly direct") || text.includes("proceed direct") || text.includes("direct")) {
        reply = directFix
          ? `proceeding direct ${directFix}, ${callsign}.`
          : `proceeding as instructed, ${callsign}.`;

      // SPEED
      } else if (text.includes("reduce speed") || text.includes("increase speed") || text.includes("maintain speed") || text.includes("not above") || text.includes("not less than")) {
        reply = speedSpoken
          ? `speed ${speedSpoken} knots, ${callsign}.`
          : `speed as instructed, ${callsign}.`;

      // HOLDING
      } else if (text.includes("hold") && (text.includes("pattern") || text.includes("holding"))) {
        if (holdFix) {
          reply = `holding at ${holdFix} as instructed, ${callsign}.`;
        } else {
          reply = `holding as instructed, ${callsign}.`;
        }

      // QNH / QFE
      } else if (text.includes("qnh")) {
        reply = qnh
          ? `QNH ${spellNumberDigits(qnh)} set, ${callsign}.`
          : `QNH set, ${callsign}.`;

      } else if (text.includes("qfe")) {
        const qfeMatch = text.match(/\bqfe\s+(\d{3,4})\b/);
        const qfe = qfeMatch ? qfeMatch[1] : "";
        reply = qfe
          ? `QFE ${spellNumberDigits(qfe)} set, ${callsign}.`
          : `QFE set, ${callsign}.`;

      // SQUAWK / CONSPICUITY
      } else if (text.includes("squawk") || text.includes("transponder")) {
        if (text.includes("ident") || text.includes("identification")) {
          reply = `squawk ident, ${callsign}.`;
        } else if (squawk7000 || text.includes("vfr conspicuity")) { // VFR conspicuity.[web:131]
          reply = `squawking conspicuity, ${callsign}.`;
        } else if (squawk2000 || text.includes("ifr conspicuity")) { // IFR conspicuity.[web:131]
          reply = `squawking conspicuity, ${callsign}.`;
        } else {
          reply = squawkSpoken
            ? `squawking ${squawkSpoken}, ${callsign}.`
            : `squawking as assigned, ${callsign}.`;
        }

      } else if (text.includes("stop squawk") || text.includes("squawk standby")) {
        reply = `transponder standby, ${callsign}.`;

      // FREQUENCY / HAND-OFF
      } else if (text.includes("contact") || text.includes("monitor") || text.includes("change to")) {
        reply = freqSpoken
          ? `changing to ${freqSpoken}, ${callsign}.`
          : `changing frequency, ${callsign}.`;

      // POSITION / TRAFFIC / CIRCUIT
      } else if (text.includes("report final") || text.includes("report downwind") || text.includes("report base") || text.includes("report overhead")) {
        if (text.includes("final")) {
          reply = `will report final, ${callsign}.`;
        } else if (text.includes("downwind")) {
          reply = `will report downwind, ${callsign}.`;
        } else if (text.includes("base")) {
          reply = `will report base, ${callsign}.`;
        } else if (text.includes("overhead")) {
          reply = `will report overhead, ${callsign}.`;
        } else {
          reply = `wilco, ${callsign}.`;
        }

      } else if (text.includes("report ready")) {
        reply = `will report ready, ${callsign}.`;

      } else if (text.includes("traffic")) {
        if (text.includes("in sight")) {
          reply = `traffic in sight, ${callsign}.`;
        } else if (text.includes("not in sight") || text.includes("no visual")) {
          reply = `negative contact, ${callsign}.`;
        } else {
          reply = `looking out, ${callsign}.`;
        }

      // MISC / ACKS
      } else if (text.includes("hold position")) {
        reply = `holding position, ${callsign}.`;

      } else if (text.includes("hold short")) {
        reply = runway
          ? `holding short runway ${speakableRunway}, ${callsign}.`
          : `holding short, ${callsign}.`;

      } else if (text.includes("standby")) {
        reply = `standing by, ${callsign}.`;

      } else if (text.includes("readback correct") || text.includes("correct")) {
        reply = `roger, ${callsign}.`;

      } else if (text.includes("say again")) {
        reply = `say again, ${callsign}.`;

      } else if (text.includes("confirm")) {
        reply = `affirm, ${callsign}.`;
      }

      if (!reply) return null;
      return reply;
    }

    // ---------- SLOW-PATH LLM FALLBACK ----------

    async function askPilotAI(atcText) {
      const fast = buildPilotReplyFast(atcText);
      if (fast) return fast;

      const systemPrompt =
        "You are the pilot in a UK CAA CAP 413 style RTF exchange.\n" +
        "You receive ATC transmissions as text and must reply with ONE short, realistic pilot readback.\n" +
        "Rules:\n" +
        "- Use standard ICAO/CAA radiotelephony phraseology, UK style.\n" +
        "- Use correct telephony designators for airline callsigns when applicable.\n" +
        "- For GA registrations, you may use the NATO phonetic alphabet.\n" +
        "- Put the clearance or readback FIRST and the call sign LAST.\n" +
        "- Be concise: read back only what is required.\n" +
        "- Output ONLY the pilot’s spoken transmission, no explanations.";

      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: "ATC transmission: \"" + atcText + "\"" }
      ];

      const resp = await puter.ai.chat(messages, {
        model: "gpt-5-nano",
        stream: false
      });

      if (typeof resp === "string") return resp;
      if (resp?.message?.content) return resp.message.content;
      if (resp?.choices?.[0]?.message?.content) return resp.choices[0].message.content;
      return "say again, please.";
    }

    // ---------- TTS WRAPPER ----------

    async function speak(text) {
      const audio = await puter.ai.txt2speech(text, {
        language: "en-GB"
      });
      await audio.play();
    }

    // ---------- RECORD / PROCESS LOOP ----------

    async function onStopRecording() {
      statusDiv.textContent = "Transcribing...";
      const blob = new Blob(chunks, { type: "audio/webm" });
      chunks = [];

      try {
        const result = await puter.ai.speech2txt(blob);
        const atcText = result.text || result || "";
        youDiv.textContent = atcText || "(No speech recognised)";

        if (!atcText) {
          const fallback = "no transmission received, say again.";
          pilotDiv.textContent = fallback;
          await speak(fallback);
          statusDiv.textContent = "Ready.";
          return;
        }

        statusDiv.textContent = "Generating pilot reply...";
        const pilotText = await askPilotAI(atcText);
        pilotDiv.textContent = pilotText;

        statusDiv.textContent = "Speaking pilot reply...";
        await speak(pilotText);
        statusDiv.textContent = "Ready.";
      } catch (err) {
        console.error(err);
        statusDiv.textContent = "Error: " + err.message;
      }
    }

    // ---------- PTT HANDLERS ----------

    pttBtn.addEventListener("mousedown", async () => {
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("mouseup", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    pttBtn.addEventListener("mouseleave", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });

    // Touch support
    pttBtn.addEventListener("touchstart", async (e) => {
      e.preventDefault();
      await initMedia();
      if (!mediaRecorder) return;
      chunks = [];
      mediaRecorder.start();
      pttBtn.classList.add("recording");
      statusDiv.textContent = "Recording ATC...";
    });

    pttBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        pttBtn.classList.remove("recording");
        statusDiv.textContent = "Processing...";
      }
    });
  </script>
</body>
</html>
